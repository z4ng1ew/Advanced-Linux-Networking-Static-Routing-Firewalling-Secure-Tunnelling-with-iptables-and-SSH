## 1.1. Сети и маски
Определить и записать в отчёт:
```bash
ipcalc 192.167.38.54/13
```
![part1](./img/1.1.192.167.38.54.png)
- 192.160.0.0 - адрес










## 1.2. Перевод маски
## 1.1.2.1 Перевод маски *255.255.255.0* в префиксную и двоичную запись

![part1](./img/1.2.255.255.255.0.png)
На изображении представлен результат выполнения команды `ipcalc` для маски 255.255.255.0. Здесь показаны:

- **Address:** 255.255.255.0 (IP-адрес)
- **Netmask:** 255.255.255.0, которая в двоичной записи представлена как `11111111.11111111.11111111.00000000`, и это соответствует префиксу `/24`.
- **Network:** 255.255.255.0/24 (сеть)
- **HostMin и HostMax:** диапазон хостов в этой сети, от 255.255.255.1 до 255.255.255.254.
- **Broadcast:** 255.255.255.255 (адрес широковещательной рассылки)
- **Hosts/Net:** 254 хоста могут быть использованы в этой сети.

Этот вывод подтверждает, что маска `255.255.255.0` соответствует префиксу `/24`. 

### После выполнения команды, видим результат, который включает в себя:
- Netmask: 255.255.255.0 = 24 (это и есть префиксная запись)
- Двоичная запись: 11111111.11111111.11111111.00000000





## 1.1.2.2 Перевод маски */15* в обычную и двоичную
    - 255.254.0.0 - обычная
    - 11111111.11111110.00000000.00000000 - двоичная

  - ![part1](./img/3.sipcalc000015.png)
  
  - ![part1](./img/3.слеш_15.png)

  - ![part1](./img/3.0.0.015.png)
 На скриншоте указана информация, полученная после выполнения команды `ipcalc 0.0.0.0/15`. 

**Что показано на скриншоте:**

1. **Address**: 0.0.0.0 — адрес сети, который был введен для анализа.
2. **Netmask**: 255.254.0.0 = 15 — маска подсети в десятичной записи и в префиксной записи (/15).
3. **Wildcard**: 0.1.255.255 — обратная маска (используется в некоторых сетевых настройках).
4. **Network**: 0.0.0.0/15 — сеть, соответствующая маске /15.
5. **Broadcast**: 0.1.255.255 — широковещательный адрес для данной сети.
6. **HostMin**: 0.0.0.1 — минимальный адрес хоста в этой сети.
7. **HostMax**: 0.1.255.254 — максимальный адрес хоста в этой сети.
8. **Hosts/Net**: 131070 — количество возможных адресов хостов в этой сети.
9. **Dotted Binary Netmask**: 11111111.11111110.00000000.00000000 — маска подсети в двоичном формате.

Этот скриншот показывает, как выглядит маска `/15` в десятичной и двоичной записи:


Обычная запись:
- Это строка, где указана Netmask: 255.254.0.0.

Двоичная запись:

- Это строка, где указана Dotted Binary Netmask: 11111111.11111110.00000000.00000000.







## 1.1.2.3. Перевод маски  11111111.11111111.11111111.11110000 в обычную и префиксную

Можно перевести бинарную маску, как например, `11111111.11111111.11111111.11110000`, в обычную и префиксную маску с помощью терминала, но для этого потребуется несколько шагов.

1. **Для перевода бинарной маски в десятичную (обычную) маску**, можно использовать команду `echo` и утилиту `bc` (или сделать это вручную).

Пример:

```bash
echo "ibase=2; 11111111" | bc
```

Для всей маски нужно будет перевести каждую часть отдельно (первую, вторую, третью и четвертую). Маска будет выглядеть как:

- 11111111 (255)
- 11111111 (255)
- 11111111 (255)
- 11110000 (240)

Можете использовать команду, которая преобразует всю бинарную маску в десятичную:

```bash
echo "ibase=2; 11111111" | bc
echo "ibase=2; 11111111" | bc
echo "ibase=2; 11111111" | bc
echo "ibase=2; 11110000" | bc
```

После этого вы получите результат:

```
255
255
255
240
```

Таким образом, маска в десятичной записи будет: **255.255.255.240**.

2. **Для получения префиксной записи**, достаточно посчитать количество единичных бит в маске.

Бинарная маска `11111111.11111111.11111111.11110000` содержит **28 единичных бит**.

Следовательно, префиксная запись будет `/28`.

Чтобы объединить оба шага и автоматизировать это с помощью командной строки, можно использовать скрипт. Например, так:

```bash
#!/bin/bash
binary_mask="11111111.11111111.11111111.11110000"
octets=($(echo $binary_mask | tr '.' '\n'))  # Разбиваем на части по точкам
for i in "${octets[@]}"; do
  echo $((2#$i))  # Переводим каждую часть в десятичное число
done
```
![part1](./img/1.2.3.1.script_rerevoda_binar.png)

Этот скрипт разделяет маску на октеты, затем переводит каждый октет в десятичную форму.

## Итог:
- **Обычная маска**: `255.255.255.240`
- **Префиксная маска**: `/28`

- ![part1](./img/1.2.3.2.res_script.png)




Для перевода двоичной маски `11111111.11111111.11111111.11110000` в обычную десятичную и префиксную запись с помощью команды, также можно воспользоваться утилитой `ipcalc`. Однако, `ipcalc` обычно работает с десятичной записью маски или префиксом, а не с двоичной. Чтобы выполнить это задание вручную, давайте сначала разберёмся, как это сделать:

1. **Перевод в обычную (десятичную) запись:**
   - `11111111` в двоичной — это `255` в десятичной.
   - `11111111` в двоичной — это `255` в десятичной.
   - `11111111` в двоичной — это `255` в десятичной.
   - `11110000` в двоичной — это `240` в десятичной.

   Итак, маска `11111111.11111111.11111111.11110000` соответствует `255.255.255.240`.

2. **Перевод в префиксную запись:**
   - Подсчитываем количество единиц в двоичной маске: `28` единиц.
   Префиксная запись будет `/28`.


Теперь, как можно сделать это с помощью `ipcalc`:

- ![part1](./img/1.2.3.not_binary.png)

1. **Определение маски:**

   Мы можем использовать `ipcalc` для вычисления сети с маской `/28` и она покажет нам десятичную маску:

   ```bash
   ipcalc 192.168.0.0/28
   ```

   Эта команда покажет нам маску `255.255.255.240`.

2. **Преобразование двоичной маски вручную:**

   Если нужно просто получить результат:

   - Обычная запись: `255.255.255.240`
   - Префикс: `/28`

Нет команды, которая бы напрямую приняла двоичную маску и вернула десятичную и префиксную записи. Нужно сначала перевести маску вручную или использовать десятичный формат для ввода в `ipcalc`.











## 1.1.3.1. Определил и записал в отчёт минимальный и максимальный хост в сети *12.167.38.4* при масках:

## 1.3.1 */8*, команда - ipcalc 12.167.38.4/8
  - 12.0.0.1 - min
  - 12.255.255.254 - max

![part1](./img/1.1.1.3.MIN_MAX_1.png)





## 1.1.3.2 Определил и записал в отчёт минимальный и максимальный хост в сети при маске 11111111.11111111.00000000.00000000 (что эквивалентно 255.255.0.0 или 16  )

## команда - ipcalc 12.167.38.4    255.255.0.0

![part1](./img/1.1.1.4.MIN_MAX_2.png)

## Минимальный и максимальный хосты:
- **Минимальный хост:** `12.167.0.1`
- **Максимальный хост:** `12.167.255.254`





## 1.1.3.3 Определил и записал в отчёт минимальный и максимальный хост в сети при маске  /4:

## команда - ipcalc 12.167.38.4/4


![part1](./img/1.1.3.3.MIN_MAX_3.png)
- */4*
  - 0.0.0.1 - min
  - 15.255.255.254 - max








## 1.2. localhost.

## 1.2.1.1. localhost. Определить и записать в отчёт, можно ли обратиться к приложению, работающему на localhost, со следующими IP:

> Адреса на localhost должны находиться в диапазоне 127.0.0.1 - 127.255.255.254

`localhost` — это специальный зарезервированный IP-адрес, который всегда указывает на текущую машину. Обычно, этот адрес представлен как `127.0.0.1` и относится к сети `127.0.0.0/8`. Все IP-адреса в диапазоне `127.x.x.x` предназначены для "обратной связи", т.е., для связи самой системы с собой.

![part1](./img/1.2.1.1.LOCALHOST_1.png)

1. *194.34.23.100* -  нельзя. Это публичный IP-адрес, который также не входит в диапазон `127.0.0.0/8`. Он может принадлежать любому устройству в интернете, но не моему компьютеру в рамках `localhost`.




![part1](./img/1.2.1.2.LOCALHOST_2.png)

2. *127.0.0.2* - можно




![part1](./img/1.2.1.3.LOCALHOST_3.png)

3. *127.1.0.1* - можно




![part1](./img/1.2.1.4.LOCALHOST_4.png)

4. *128.0.0.1* - нельзя. Этот адрес не входит в диапазон `127.0.0.0/8`. Он принадлежит другой сети. Например, `128.0.0.0/8` — это другая сеть, где маска подсети также `255.0.0.0`, но первый октет адреса — `128`, а не `127`.













## 1.3. Диапазоны и сегменты сетей
## Определи и запиши в отчёт:

## 1) Какие из перечисленных IP можно использовать в качестве публичного, а какие только в качестве частных: 10.0.0.45, 134.43.0.2, 192.168.4.2, 172.20.250.4, 172.0.2.1, 192.172.0.1, 172.68.0.2, 172.16.255.255, 10.10.10.10, 192.169.168.1

`ЗДЕСЬ Я  ПОМЕНЯЛ ПОЛЬЗОВАТЕЛЯ ТАК КАК ВЫНУЖДЕН БЫЛ ВЫПОЛНЯТЬ ЗАДАНИЯ НА ПК РАБОТОДАТЕЛЯ А НЕ НА ДОМАШНЕМ ПК, ПОЭТОМУ ПОЛЬЗОВАТЕЛЬ ДРУГОЙ`

- 10.0.0.45 — частный <br>
![part1](./img/9.0.png)


- 134.43.0.2 — публичный <br>
![part1](./img/9.1.png)
   
- 192.168.4.2 — частный <br>
![part1](./img/9.2.png)

- 172.20.250.4 — частный <br>
![part1](./img/9.3.png)

- 172.0.2.1 — публичный <br>
![part1](./img/9.4.png)
  
- 192.172.0.1 — публичный <br>
![part1](./img/9.5.png)

- 172.68.0.2 — публичный <br>
![part1](./img/9.6.png)
   
- 172.16.255.255 — частный <br>
![part1](./img/9.7.png)

- 10.10.10.10 — частный <br>
![part1](./img/9.8.png)
  
- 192.169.168.1 — публичный <br>
![part1](./img/9.9.png)




## 2)  Какие из перечисленных IP-адресов шлюза возможны у сети 10.10.0.0/18: 10.0.0.1, 10.10.0.2, 10.10.10.10, 10.10.100.1, 10.10.1.255

![part1](./img/10.1.png)

Да, на основании вывода команды `ipcalc 10.10.0.0/18` можно точно определить, какие IP-адреса возможны для этой сети.


1. **10.0.0.1** — это вне диапазона (до **10.10.0.0**), так как сеть 10.10.0.0/18 начинается с **10.10.0.0**.
2. **10.10.0.2** — внутри диапазона (между **10.10.0.1** и **10.10.63.254**), это допустимый IP-адрес.
3. **10.10.10.10** — внутри диапазона (между **10.10.0.1** и **10.10.63.254**), это допустимый IP-адрес.
4. **10.10.100.1** — это вне диапазона (сеть заканчивается на **10.10.63.255**).
5. **10.10.1.255** — это внутри диапазона, но является широковещательным адресом для сети 10.10.1.0/24, а не для 10.10.0.0/18, поэтому его нельзя использовать как адрес для хоста в данной сети.










## Part 2. Статическая маршрутизация между двумя машинами

- Поднять две виртуальные машины (далее -- ws1 и ws2)

> ![part2](./img/2_task/2.png)


- С помощью команды ip a посмотрел существующие сетевые интерфейсы. В отчёт поместил скрин с вызовом и выводом использованной команды.

- ws1
  > ![part2](./img/2_task/2_ip_a.png)
- ws2
  >![part2](./img/2_task/2_ip_a_2.png)


> - Настраиваем локальное соединение на обеих машинах через VirtualBox.
![part2](./img/2_task/2.1.png)

На скриншоте показано окно настройки сети в программе VirtualBox, находящееся в разделе "Сети NAT". В этом разделе отсутствуют созданные сети NAT, что означает, что ни одна из виртуальных машин в данный момент не подключена к сети NAT. На панели слева видны две виртуальные машины — ws1 и ws2, которые находятся в сохраненном состоянии.




![part2](./img/2_task/2.3.png)
![part2](./img/2_task/2.2.png)


На скриншоте показаны настройки сети для виртуальной машины ws2  и ws1 в Oracle VM VirtualBox. Настройка произведена во вкладке "Сеть" в параметрах виртуальной машины. Здесь видно, что Адаптер 1 подключен и настроен на использование типа подключения "Внутренняя сеть" (Internal Network). Также указано имя сети "InternalNetwork", что обеспечивает соединение данной виртуальной машины с другими виртуальными машинами, подключенными к той же внутренней сети.

![part2](./img/2_task/2.4.png)
![part2](./img/2_task/2.5.png)



## Описание скриншотов:

На предоставленных скриншотах показаны настройки сетевого адаптера двух виртуальных машин (WS1 и WS2) в VirtualBox.

## Скриншот 1 (WS1):
На скриншоте отображена вкладка "Сеть" в настройках виртуальной машины WS1. 
- **Адаптер 2** активирован и настроен на использование **Внутренней сети** с именем **InternalNetwork**.
- Важно: это позволяет виртуальным машинам WS1 и WS2 взаимодействовать друг с другом, используя внутреннюю сеть, изолированную от внешнего интернета.

## Скриншот 2 (WS2):
На скриншоте показаны аналогичные настройки для виртуальной машины WS2. 
- **Адаптер 2** также активирован и настроен на использование **Внутренней сети** с именем **InternalNetwork**, что позволяет обеим виртуальным машинам обмениваться данными друг с другом внутри этой внутренней сети.

## Цель:

Открыл настройки сети виртуальных машин WS1 и WS2 в VirtualBox для того, чтобы убедиться, что обе машины подключены к одной и той же внутренней сети. Это необходимо для выполнения задания по настройке статической маршрутизации между двумя виртуальными машинами. Подключение через внутреннюю сеть обеспечит связь между WS1 и WS2, что является основой для последующей настройки маршрутизации и обмена данными между этими машинами без использования внешних сетей, таких как интернет.

Настройки внутренней сети с именем **InternalNetwork** позволяют WS1 и WS2 взаимодействовать друг с другом напрямую, что необходимо для выполнения учебного задания по статической маршрутизации.







- Описать сетевой интерфейс, соответствующий внутренней сети, на обеих машинах и задать следующие адреса и маски: ws1 - *192.168.100.10*, маска */16*, ws2 - *172.24.116.8*, маска */12*
- В отчёт поместить скрины с содержанием изменённого файла *etc/netplan/00-installer-config.yaml* для каждой машины. 
- ws1 <br>
![part2](./img/2_task/2.7.png)
- ws2 <br>
![part2](./img/2_task/2.6.png)


-Выполнить команду `netplan apply` для перезапуска сервиса сети. В отчёт поместить скрин с вызовом и выводом использованной команды.

- ws1 <br>
![part2](./img/2_task/2.8.png)
- ws2 <br>
![part2](./img/2_task/2.9.png)


## Описание скриншотов и цели

**Цель:**
Настроить статические IP-адреса для сетевых интерфейсов `enp0s8` на двух виртуальных машинах (`ws1` и `ws2`) для создания сети между ними. Эти настройки необходимы для дальнейшего добавления статических маршрутов и проверки соединения между машинами.

**Скриншот 1 (ws2):**

На скриншоте показан файл `/etc/netplan/00-installer-config.yaml` на машине `ws2`. В этом файле настроен сетевой интерфейс `enp0s8` с использованием статического IP-адреса `172.24.116.8` с маской подсети `/12`.

**Скриншот 2 (ws1):**

На скриншоте показан файл `/etc/netplan/00-installer-config.yaml` на машине `ws1`. В этом файле настроен сетевой интерфейс `enp0s8` с использованием статического IP-адреса `192.168.100.10` с маской подсети `/16`.

## Команды, используемые для выполнения задачи:

1. **Открытие и редактирование файла конфигурации сетевого интерфейса:**

   Для машины `ws2`:
   ```bash
   sudo nano /etc/netplan/00-installer-config.yaml
   ```

   Для машины `ws1`:
   ```bash
   sudo nano /etc/netplan/00-installer-config.yaml
   ```

2. **Сохранение изменений в файле и применение настроек сети:**

   После редактирования файла конфигурации, сохранены изменения и закрыт редактор (в `nano` это делается нажатием `Ctrl+S`, затем `Enter` для сохранения, и `Ctrl+X` для выхода).

3. **Применение новых сетевых настроек:**

   На обеих машинах выполнена команда:
   ```bash
   sudo netplan apply
   ```




- ws1 <br>
![part2](./img/2_task/ws1_apply.png)
- ws2 <br>
![part2](./img/2_task/ws2_apply.png)





## 2.1. Добавление статического маршрута вручную

 1. Добавь статический маршрут от одной машины до другой и обратно при помощи команды вида ip r add.



 2.  В отчёт помести скрин с вызовом и выводом использованных команд.
- ws1 <br>
![part2](./img/2_task/ip_r_add_ws1.png)
- ws2 <br>
![part2](./img/2_task/ip_r_add_ws2.png)


При добавлении статического маршрута необходимо указывать именно сетевой адрес, а не адрес конкретного узла. Вот подробное объяснение для отчёта:

1. **Сетевая адресация по маске /16:**
   - При маске /16 сеть охватывает адреса от 192.168.0.0 до 192.168.255.255.
   - Сетевой адрес – это первый адрес диапазона (в данном случае 192.168.0.0), который служит идентификатором всей сети.

2. **Назначение статического маршрута:**
   - Статический маршрут используется для указания системы, что весь трафик, направленный в определённую сеть, должен отправляться через заданный шлюз.
   - Команда `sudo ip route add 192.168.0.0/16 via 172.24.116.8` сообщает системе, что для доступа к любому узлу в сети 192.168.0.0/16 (то есть для всех адресов от 192.168.0.0 до 192.168.255.255) нужно использовать шлюз 172.24.116.8.

3. **Почему не 192.168.100.10/16:**
   - Адрес 192.168.100.10 является адресом конкретного хоста, а не сетевым адресом.
   - Если указать 192.168.100.10/16, система будет ожидать, что 192.168.100.10 – это начало диапазона сети, что неверно, так как для сети с маской /16 корректным сетевым адресом является 192.168.0.0.
   - Таким образом, использование адреса 192.168.100.10/16 приведёт к ошибке, так как он не соответствует правильному сетевому адресу для заданной маски.

**Вывод:**  
Для корректной маршрутизации необходимо указать сетевой адрес 192.168.0.0/16, чтобы охватить всю сеть, а не отдельный адрес узла. Это гарантирует, что трафик для любого устройства в сети будет направлен через нужный шлюз (в данном случае через 172.24.116.8).


 3. Пропингуй соединение между машинами.
- ws1 <br>
![part2](./img/2_task/ping_ip_r_ws1.png)
- ws2 <br>
![part2](./img/2_task/ping_ip_r_ws2.png)







## 2.2. Добавление статического маршрута с сохранением

1. Перезапусти машины.

2. Добавь статический маршрут от одной машины до другой с помощью файла /etc/netplan/00-installer-config.yaml.

3. В отчёт помести скрин с содержанием изменённого файла /etc/netplan/00-installer-config.yaml.
![part2](./img/2_task/ws2_ststick_rout_adress.png)
![part2](./img/2_task/ws1_ststick_rout_adress.png)


4. Пропингуй соединение между машинами.

5. В отчёт помести скрин с вызовом и выводом использованной команды.
- ws1 <br>
![part2](./img/2_task/ws1_ping_statick_route.png)
- ws2 <br>
![part2](./img/2_task/ws2_ping_statick_route.png)










## Part 3. Утилита iperf3
## **3.1. Перевод единиц скорости**

1. **8 Mbps** в **MB/s**  **= 1 MB/s**
2. **100 MB/s** в **Kbps**  **= 800000 Kbps**
3. **1 Gbps** в **Mbps**  **= 1000 Mbps**

- ![part2](./img/3_task/math_of_speed.png)

---

## **3.2. Измерение скорости с iperf3**

## **1. Установка iperf3 (если не установлен)**
На обеих виртуальных машинах `ws1` и `ws2` установи утилиту iperf3:
```bash
sudo apt update && sudo apt install -y iperf3
```


- В отчёт поместить скрины с вызовом и выводом использованных команд.
>
> - ws1
>
 `iperf -s`
 
- ![](./img/3_task/iperf3_ws1.png)

> - ws2

>   `iperf -c 192.168.100.10`

- ![](./img/3_task/iperf_ws2.png)







## 4.1. Утилита iptables


Создай файл /etc/firewall.sh, имитирующий файрвол, на ws1 и ws2:

#!/bin/sh

## Удаление всех правил в таблице «filter» (по умолчанию).
iptables -F
iptables -X



Нужно добавить в файл подряд следующие правила:

1) На ws1 примени стратегию, когда в начале пишется запрещающее правило, а в конце пишется разрешающее правило (это касается пунктов 4 и 5).

2) На ws2 примени стратегию, когда в начале пишется разрешающее правило, а в конце пишется запрещающее правило (это касается пунктов 4 и 5).

3) Открой на машинах доступ для порта 22 (ssh) и порта 80 (http).

4) Запрети echo reply (машина не должна «пинговаться», т. е. должна быть блокировка на OUTPUT).

5) Разреши echo reply (машина должна «пинговаться»).

В отчёт помести скрины с содержанием файла /etc/firewall для каждой машины.


> ![](./img/4_task/firewall_ws1.png)

> ![](./img/4_task/firewall_ws2.png)



---

Запусти файлы на обеих машинах командами chmod +x /etc/firewall.sh и /etc/firewall.sh.

> ![](./img/4_task/sudo_chmod_firewall_ws1.png)

> ![](./img/4_task/sudo_chmod_firewall_ws2.png)

В отчёт помести скрины с запуском обоих файлов.
В отчёте опиши разницу между стратегиями, применёнными в первом и втором файлах.




> ![](./img/4_task/sudo_firewall_ping_ws1.png)

> ![](./img/4_task/sudo_firewall_ping_ws2.png)



## **Разница между стратегиями**
- **ws1**: сначала запрещаем ICMP, потом разрешаем (в итоге ICMP **разрешён**).  
- **ws2**: сначала разрешаем ICMP, потом запрещаем (в итоге ICMP **запрещён**).  

Таким образом, **ws1 пингуется, а ws2 нет**.






## 4.2. Утилита nmap


 - Командой ping найди машину, которая не «пингуется», после чего утилитой nmap покажи, что хост машины запущен.
Проверка: в выводе nmap должно быть сказано: Host is up.
> ![](./img/4_task/sudo_firewall_ping_ws2.png)

 - В отчёт помести скрины с вызовом и выводом использованных команд ping и nmap.


- ws1
> ![](./img/4_task/nmap_172.png)
- ws2
> ![](./img/4_task/nmap_192.png)






Сохрани дампы образов виртуальных машин
P.S. Ни в коем случае не сохраняй дампы в гит!


- ws1
> ![](./img/4_task/snap_ws1.png)
- ws2
> ![](./img/4_task/snap_ws1.png)


> ![](./img/4_task/Ova.png)



## Part 5. Статическая маршрутизация сети

- Поднять пять виртуальных машин (3 рабочие станции (ws11, ws21, ws22) и 2 роутера (r1, r2))



## 5.1. Настройка адресов машин

Настрой конфигурации машин в etc/netplan/00-installer-config.yaml согласно сети на рисунке.
> ![](./img/5_task/r1.png)
> ![](./img/5_task/r2.png)
> ![](./img/5_task/ws11.png)
> ![](./img/5_task/ws21.png)
> ![](./img/5_task/ws22.png)

- В отчёт помести скрины с содержанием файла etc/netplan/00-installer-config.yaml для каждой машины.


- Перезапусти сервис сети. Если ошибок нет, командой ip -4 a проверь, что адрес машины задан верно.

> ![](./img/5_task/ip4a_r1.png)
> ![](./img/5_task/ip4a_r2.png)
> ![](./img/5_task/ip4a_ws11.png)
> ![](./img/5_task/ip4a_ws21.png)
> ![](./img/5_task/ip4a_ws22.png)

<br>

 - Также пропингуй ws22 с ws21. 
 - ws21
> ![](./img/5_task/ws21_Ping.png)
 - ws22
> ![](./img/5_task/ws22_ping.png)

 



- Аналогично пропингуй r1 с ws11.

- ws11
> ![](./img/5_task/ws11_ping.png)
- r1
> ![](./img/5_task/r1_ping.png)

- В отчёт помести скрины с вызовом и выводом использованных команд.



## 5.2. Включение переадресации IP-адресов

- Для включения переадресации IP выполни команду на роутерах:
- sysctl -w net.ipv4.ip_forward=1

- r1
> ![](./img/5_task/forward_r1.png)
- r2
> ![](./img/5_task/forward_r2.png)

- При таком подходе переадресация не будет работать после перезагрузки системы.

- В отчёт помести скрин с вызовом и выводом использованной команды.


Открой файл /etc/sysctl.conf и добавь в него следующую строку:
net.ipv4.ip_forward = 1

> ![](./img/5_task/uncomment_r1.png)
> ![](./img/5_task/uncomment_r2.png)




При использовании этого подхода, IP-переадресация включена на постоянной основе.

В отчёт помести скрин с содержанием изменённого файла /etc/sysctl.conf.














## 5.3. Установка маршрута по умолчанию
Пример вывода команды ip r после добавления шлюза:

default via 10.10.0.1 dev eth0
10.10.0.0/18 dev eth0 proto kernel scope link src 10.10.0.2



Настрой маршрут по умолчанию (шлюз) для рабочих станций. Для этого добавь default перед IP-роутера в файле конфигураций.

В отчёт помести скрин с содержанием файла etc/netplan/00-installer-config.yaml;

> ![](./img/5_task/via_routes_ws11.png) 
> ![](./img/5_task/via_routes_ws21.png) 
> ![](./img/5_task/via_routes_ws22.png) 


Вызови ip r и покажи, что добавился маршрут в таблицу маршрутизации.

В отчёт помести скрин с вызовом и выводом использованной команды.
> ![](./img/5_task/statick_ws11.png) 
> ![](./img/5_task/statick_ws21.png) 
> ![](./img/5_task/statick_ws22.png) 




Пропингуй с ws11 роутер r2 и покажи на r2, что пинг доходит. Для этого используй команду:
tcpdump -tn -i eth0

В отчёт помести скрин с вызовом и выводом использованных команд.

> ![](./img/5_task/tcpdump.png) 




## 5.4. Добавление статических маршрутов

Добавь в роутеры r1 и r2 статические маршруты в файле конфигураций. Пример для r1 маршрута в сетку 10.20.0.0/26:

## Добавь в конец описания сетевого интерфейса eth1:
```
- to: 10.20.0.0
  via: 10.100.0.12
```


В отчёт помести скрины с содержанием изменённого файла etc/netplan/00-installer-config.yaml для каждого роутера.


> ![](./img/5_task/sudo_netplan_r1.png) 
> ![](./img/5_task/sudo_netplan_r2.png) 


> ![](./img/5_task/apply_sudo_netplan_r1.png) 
> ![](./img/5_task/apply_sudo_netplan_r2.png) 

Вызови ip r и покажи таблицы с маршрутами на обоих роутерах. Пример таблицы на r1:

10.100.0.0/16 dev eth1 proto kernel scope link src 10.100.0.11
10.20.0.0/26 via 10.100.0.12 dev eth1
10.10.0.0/18 dev eth0 proto kernel scope link src 10.10.0.1


В отчёт помести скрин с вызовом и выводом использованной команды.

> ![](./img/5_task/ipr_r1.png) 
> ![](./img/5_task/ipr_r2.png) 


Запусти команды на ws11:
ip r list 10.10.0.0/[маска сети] и ip r list 0.0.0.0/0
> ![](./img/5_task/list_ws11.png) 



В отчёт помести скрин с вызовом и выводом использованных команд;
В отчёте объясни, почему для адреса 10.10.0.0/[маска сети] был выбран маршрут, отличный от 0.0.0.0/0, хотя он попадает под маршрут по умолчанию.

### Объяснение:
```  
Когда компьютер получает пакет, система сначала ищет самый конкретный маршрут для его доставки. В таблице маршрутизации маршруты с более длинной (точной) маской имеют приоритет перед более общими маршрутами.

Например, маршрут 10.10.0.0/18 охватывает диапазон, куда попадает IP-адрес ws11 (10.10.0.2). Это означает, что когда пакет адресован в диапазон 10.10.0.0/18, система видит, что этот маршрут специально определён для этой подсети, и выбирает его, даже если этот адрес также удовлетворяет условию маршрута по умолчанию (0.0.0.0/0).

Маршрут по умолчанию действует как запасной вариант для всех адресов, для которых нет более конкретного правила. Поэтому для пакетов, адресованных в диапазоны, не покрытые узким маршрутом, используется именно маршрут по умолчанию (например, через шлюз 10.10.0.1).

Таким образом, конкретный маршрут для 10.10.0.0/18 имеет приоритет, поскольку он точнее описывает, как доставлять пакеты в эту сеть, а маршрут по умолчанию используется для всех остальных случаев.
```











## 5.5. Построение списка маршрутизаторов
Пример вывода утилиты traceroute после добавления шлюза:

1 10.10.0.1 0 ms 1 ms 0 ms
2 10.100.0.12 1 ms 0 ms 1 ms
3 10.20.0.10 12 ms 1 ms 3 ms



Запусти на r1 команду дампа:
tcpdump -tnv -i eth0


- установка traceroute
> ![](./img/5_task/ws11_traceroute_install.png) 

При помощи утилиты traceroute построй список маршрутизаторов на пути от ws11 до ws21.


В отчёт помести скрины с вызовом и выводом использованных команд (tcpdump и traceroute);


> ![](./img/5_task/tcp_dump_r1_two.png) 
> ![](./img/5_task/tracerote_tcpdump_ws11.png)
> ![](./img/5_task/tracerote_tcpdump_r1.png) 



В отчёте, опираясь на вывод, полученный из дампа на r1, объясни принцип работы построения пути при помощи traceroute.




## Принцип работы утилиты `traceroute`

1. **TTL (Time To Live)** — это поле в заголовке IP-пакета, которое определяет максимальное количество маршрутизаторов (хопов), через которые пакет может пройти, прежде чем будет уничтожен. Каждый маршрутизатор по пути уменьшает TTL на 1, и если TTL достигает 0, пакет уничтожается, а отправитель получает сообщение о превышении времени жизни (Time Exceeded).

2. **Основной процесс работы `traceroute`**:
   - Утилита отправляет пакет с **TTL=1** и ожидает, пока первый маршрутизатор не ответит ICMP-сообщением **Time Exceeded**. Это означает, что TTL пакета был уменьшен до 0.
   - Затем отправляется следующий пакет с **TTL=2**, и так далее, пока пакет не достигнет целевого узла. Каждый маршрутизатор, через который проходит пакет, уменьшает TTL на 1 и посылает сообщение об исключении времени жизни.
   - Каждый раз отправляется несколько пакетов, и для каждого измеряется время прохождения (измеряется как Round-Trip Time — RTT).

3. **Использование UDP-пакетов**:
   - По умолчанию `traceroute` использует **UDP-пакеты**, а не ICMP. Эти пакеты отправляются на случайный, обычно не использующийся порт. Когда пакет достигает целевого устройства, оно, если порт закрыт, отправляет обратно ICMP-сообщение **Destination Unreachable**, тем самым завершая трассировку.
   
4. **Цель и завершение трассировки**:
   - Когда пакет достигает целевого хоста, и если порт, на который был отправлен пакет, не открыт, целевой хост отправляет ICMP-сообщение "Destination Unreachable". Это сигнализирует о завершении трассировки, так как путь до цели найден.

#### Важные моменты в выводе `tcpdump`:

В выводе дампа `tcpdump` можно увидеть, как пакеты, проходя через маршрутизаторы, получают ответы о превышении TTL. Каждый маршрутизатор, через который проходит пакет, уменьшает TTL на 1 и посылает ICMP-сообщение **Time Exceeded**. Когда пакет достигает целевой машины, та отправляет ICMP-сообщение **Destination Unreachable**, если порт на целевом устройстве закрыт, тем самым сигнализируя о завершении трассировки.

Пример из дампа `tcpdump`:

- В выводе видно, как пакет с TTL=1 получает ICMP-сообщение от маршрутизатора 10.100.0.12 (например, **ICMP time exceeded in-transit**), что соответствует тому, что `traceroute` обнаруживает первый хоп.
- После этого пакет отправляется с TTL=2, и ответ от маршрутизатора с адресом 10.20.0.10 подтверждает второй хоп, и так далее.

#### Сводка:

1. **TTL**: каждый маршрут уменьшается на 1 с каждым хопом.
2. **Тип пакета**: `traceroute` по умолчанию использует **UDP-пакеты**, а не ICMP.
3. **Ответы маршрутизаторов**: каждый маршрутизатор отправляет ICMP-сообщение **Time Exceeded**, если TTL пакета становится равным 0.
4. **Завершение трассировки**: когда пакет достигает целевого хоста, тот отправляет **ICMP Destination Unreachable**, если порт закрыт.

Так работает утилита `traceroute`, а вывод из дампа на `r1` подтверждает этот процесс, показывая, как пакеты проходят через различные маршрутизаторы, а затем получают ответы от целевого устройства.




## 5.6. Использование протокола ICMP при маршрутизации

Запусти на r1 перехват сетевого трафика, проходящего через eth0 с помощью команды:
tcpdump -n -i eth0 icmp

> ![](./img/5_task/r1_tcpdump_no_exist.png) 

Пропингуй с ws11 несуществующий IP (например, 10.30.0.111) с помощью команды:
ping -c 1 10.30.0.111


> ![](./img/5_task/ws11_ping_no_exist_ip.png)



В отчёт помести скрин с вызовом и выводом использованных команд.

Сохрани дампы образов виртуальных машин.
P.S. Ни в коем случае не сохраняй дампы в гит!

> ![](./img/5_task/dr1.png) 
> ![](./img/5_task/d_r2.png) 
> ![](./img/5_task/d_ws11.png) 
> ![](./img/5_task/d_ws21.png) 
> ![](./img/5_task/d_ws22.png) 


















## Part 6. Динамическая настройка IP с помощью DHCP

- Следующим нашим шагом будет более подробное знакомство со службой DHCP, которую ты уже знаешь.
== Задание ==
В данном задании используются виртуальные машины из Части 5.

Для r2 настрой в файле /etc/dhcp/dhcpd.conf конфигурацию службы DHCP:

1) Укажи адрес маршрутизатора по умолчанию, DNS-сервер и адрес внутренней сети. Пример файла для r2:

subnet 10.100.0.0 netmask 255.255.0.0 {}

subnet 10.20.0.0 netmask 255.255.255.192
{
    range 10.20.0.2 10.20.0.50;
    option routers 10.20.0.1;
    option domain-name-servers 10.20.0.1;
}



## 6.1 Настройка службы DHCP на r2
Утилита isc-dhcp-server ещё не установлена,  файла /etc/dhcp/dhcpd.conf ещё не существует в нужном виде. Соотвтетственно для работы с протоколом DHCP сначала надо установить эту утилиту. На скриншоте показанно состояние после установки. Можно увидеть что утилита уже установлена.

> ![](./img/6_task/r2_dhcp_install.png) 

- утилита установленна


Файл dhcpd.conf без редактирования:

> ![](./img/6_task/dhcpd-conf_r2.png) 

После этого можно для виртуальной машины r2  настроить в файле /etc/dhcp/dhcpd.conf конфигурацию службы DHCP. Указываем адрес маршрутизатора по-умолчанию, DNS-сервер и адрес внутренней сети.
Редактируем файл /etc/dhcp/dhcpd.conf 

```
sudo nano /etc/dhcp/dhcpd.conf
```

> ![](./img/6_task/change_dhcp-conf_r2.png) 




Нужно изменить /etc/resolv.conf(содержит адреса серверов имен, к которым имеет доступ данная система) прописываем nameserver 8.8.8.8
```
sudo nano /etc/resolv.conf
```

![alt text](./img/6_task/resolv_conf_no_reduction_r2.png)

- после изменений 

![alt text](./img/6_task/8.8.8.8_resolv_conf_r2.png) 



Перезапаустим службу DHCP
```
systemctl restart isc-dhcp-server
```

![alt text](./img/6_task/reboot_dhcp_r2.png) 


Проверяем статус службы

```
sudo systemctl status isc-dhcp-server
```

![alt text](./img/6_task/status_dhcp.png)


Поменяем настройки машин ws21 и ws22 в netplan конфигурации, чтобы сделать  DHCP активным. Введём команды на каждой из машин:

```
sudo nano /etc/netplan/00-installer-config.yaml

sudo netplan apply
```


![alt text](./img/6_task/ws21_ws21_netplan_apply.png) 
![alt text](./img/6_task/ws22_config_netplan_dhcp.png) 
![alt text](./img/6_task/ws21_config_netplan_dhcp.png)




Ставим машину ws21 на перезагрузку:
![alt text](img/6_task/reboot_ws21.png) 









Смотрим присвоенные для виртуальных машин ws1 ws2  ip-адреса:

![alt text](img/6_task/ws21_ip.png)

![alt text](img/6_task/ws22_ip.png) 



- Пингуем соединение машины ws22 с ws21

![alt text](img/6_task/ping_ws22_with_ws21.png)









 
## 6.2 Указать MAC-адреса
 **6.2 Назначение MAC-адреса и настройка DHCP**

📄 **Изменение конфигурации Netplan на ws11**  
В файл `/etc/netplan/00-installer-config.yaml` добавлен параметр `macaddress: 10:10:10:10:10:BA` и включена настройка `dhcp4: true` для получения IP-адреса по DHCP.  
После применения настроек командой `sudo netplan apply` машина выключается для последующего ручного указания MAC-адреса в VirtualBox.
```
sudo nano /etc/netplan/00-installer-config.yaml
sudo netplan apply
```
![alt text](img/6_task/ws11_net_plan_apply.png) 


🖥️ **Настройка MAC-адреса в VirtualBox**  
В настройках виртуальной машины `ws11` вручную установлен MAC-адрес, соответствующий заданному в конфигурации Netplan. Это необходимо для того, чтобы DHCP-сервер мог идентифицировать машину и выдать ей нужный IP-адрес.

Выключаем машину ws11
```
 sudo shutdown -h now
```
Заходим в менеджер виртуальных машин VirtualBox и там настраиваем ws11 MAC-адрес
![alt text](img/6_task/MANAGER_WS11.png) 





📦 **Настройка DHCP-сервера на маршрутизаторе r1**  
На r1 установлен и настроен `isc-dhcp-server`. В конфигурационном файле `/etc/dhcp/dhcpd.conf` прописана статическая привязка IP-адреса к MAC-адресу `ws11`. Также указан шлюз и DNS-сервер.
![alt text](img/6_task/dhcp_server_install_r1.png)
![alt text](img/6_task/r1_dhcp_conf.png) 

🔧 **Настройка DNS через resolv.conf**  
Файл `/etc/resolv.conf` на r1 обновлён для указания актуального DNS-сервера, что обеспечивает корректное разрешение доменных имён на клиентских машинах.

![alt text](img/6_task/r1_resolv_conf.png) 


🚀 **Перезапуск и проверка службы DHCP**  
 - После всех изменений перезапущена служба DHCP (`systemctl restart isc-dhcp-server`) и проверен её статус, чтобы убедиться в корректной работе сервиса.

![alt text](img/6_task/r1_systemctl_restart_isc-dhcp-server.png) 
![alt text](img/6_task/r1_stasus_isc-dhcp-server.png)


📡 Назначение IP-адреса и проверка соединения
Машине ws11 назначен IP 10.10.0.4, что подтверждено командой ip a. Выполнено тестовое соединение (ping) между машинами (например, с ws22 на ws11) для проверки доступности по сети.

![alt text](img/6_task/ip_a_ws11.png) 
![alt text](img/6_task/ws11_ping_-c_5_10.10.0.4.png) 





## **6.3 Работа с IP-адресами через dhclient**

🔍 **Анализ IP-адреса до запроса**  
 - На машине `ws21` зафиксирован текущий IP-адрес до выполнения команды `dhclient`, чтобы увидеть изменения после обновления аренды.

![alt text](img/6_task/ip_a_ws21.png)


📥 **Запрос нового IP через dhclient**  
С помощью команды `sudo dhclient -v` на `ws21` выполняется повторный запрос IP-адреса от DHCP-сервера. Ключ `-v` позволяет проследить все этапы взаимодействия с сервером.



![alt text](img/6_task/ws21_sudo_dhclient.png) 

📤 **Освобождение IP-адреса (release)**  
Выполнена команда `sudo dhclient -r` для явного освобождения текущего IP-адреса, после чего адрес снимается с интерфейса.



![alt text](img/6_task/ws21_sudo_dhclient_-r.png) 


🎯 **Применение команд к конкретному интерфейсу**  
В случае, если на машине несколько сетевых интерфейсов, можно выполнять команды `dhclient` и `dhclient -r`, указав нужный интерфейс, например: `sudo dhclient -r eth0`, `sudo dhclient eth0`.

🔄 **Повторная проверка IP-адреса**  
После каждого действия фиксируется результат командой `ip a`, чтобы отслеживать изменения адреса и подтвердить корректность работы DHCP.

---

**Итог по заданию (часть 6)**

📌 В процессе выполнения задания были задействованы ключевые опции DHCP-протокола:  
- `option routers` — для указания основного шлюза;  
- `option domain-name-servers` — для назначения DNS-серверов клиентским системам.

📦 Финальный шаг — **сохранение дампов виртуальных машин**, чтобы можно было восстановить текущую рабочую конфигурацию и использовать её в будущем или при отладке.



![alt text](img/6_task/r2_snap.png) 
![alt text](img/6_task/ws11_snap.png) 
![alt text](img/6_task/ws21_snap.png) 
![alt text](img/6_task/ws22_snap.png)
![alt text](img/6_task/r1_snap.png)
































## Part 7. NAT



##  7.1. Установка Apache2 на машины r1, r2 и ws22
💬 *Показан процесс установки веб-сервера Apache2 на все три машины, участвующие в схеме. При этом были выполнены команды `apt update`, `apt upgrade -y` и `apt install apache2`, что гарантирует актуальность пакетов и стабильную работу сервера.*

![text](img/7_task/apache_ws22_install.png) 
![text](img/7_task/apache_r2_install.png) 
![text](img/7_task/apache_r1_install.png) 
---

## 7.2. Изменение файла ports.conf на ws22 и r1
💬 *В файле конфигурации `ports.conf` изменена строка `Listen 80` на `Listen 0.0.0.0:80`, что позволяет Apache принимать подключения с любых IP-адресов, делая его доступным извне.*

![text](img/7_task/r1_apache_config_0000-80.png) 
![text](img/7_task/ws22_apache_config_0000-80.png)
---

## 7.3. Запуск Apache-сервера на ws22 и r1
💬 *Запуск службы Apache с помощью команды ` apache2 start`. Успешный запуск подтверждает корректную установку и конфигурацию веб-сервера.*

![alt text](img/7_task/ws22_apache_start_status.png) 
![alt text](img/7_task/r1_apache_start_status.png)
---

##  7.4. Очистка iptables на r2 и установка политики по умолчанию
💬 *На скриншоте показана очистка всех правил iptables и установка политики по умолчанию `FORWARD DROP`, которая блокирует маршрутизируемый трафик между интерфейсами до применения нужных правил.*

![alt text](img/7_task/r2_iptables.png) 
![alt text](img/7_task/chmod_bush.png) 
---

##  7.5. Проверка недоступности ping между r1 и ws22
💬 *После применения начальных правил фаервола пинг с r1 на ws22 не проходит, что подтверждает корректную работу запретной политики на маршрутизаторе r2.*

![alt text](img/7_task/c_r1_na_ws22_ping_two.png) 
![alt text](img/7_task/c_ws22_na_r1_ping.png) 
![alt text](img/7_task/c_r1_na_ws22_ping.png) 
---

##  7.6. Добавление разрешающего правила для ICMP
💬 *Добавлено правило, разрешающее ICMP-трафик в цепочке FORWARD, благодаря чему восстанавливается возможность обмена ping-пакетами между r1 и ws22.*

![alt text](img/7_task/подготовка_и_запуск_ping_go_netplan_config_r2.png)
![alt text](img/7_task/ping_go_netplan_config_r2.png) 
---

##  7.7. Повторная проверка соединения после разрешения ICMP
💬 *Пинг между машинами r1 и ws22 теперь проходит успешно. Это демонстрирует корректность настройки разрешающих правил в iptables на маршрутизаторе r2.*

![alt text](img/7_task/ping_с_r2_na_ws22_proverka.png)
![alt text](img/7_task/ping_с_ws22_na_r2_proverka.png) 
---

##  7.8-7.9. Настройка SNAT — маскирование внутренней сети
💬 *Добавлено правило SNAT, маскирующее внутренние IP-адреса сети 10.20.0.0/24 за внешним IP маршрутизатора r2. Это позволяет устройствам из внутренней сети выходить в Интернет, используя внешний IP r2. Настройка DNAT для проброса порта 8080 на ws22.* 

*В конфигурации iptables настроено правило DNAT: входящие подключения на порт 8080 r2 перенаправляются на порт 80 машины ws22, обеспечивая доступ к Apache-серверу, размещенному внутри локальной сети.*

![alt text](img/7_task/новая_новая_конфигурация_нетплан_r2.png) 
![alt text](img/7_task/новая_новая_конфигурация_нетплан_продолжение_r2.png) 
![alt text](img/7_task/iptables_-t_nat_-L_-n_-v_на_r2.png) 
---









## 7.10. Перед тестированием рекомендуется отключить сетевой интерфейс NAT (его наличие можно проверить командой ip a) в VirtualBox, если он включен.

![alt text](img/7_task/отключаем_НАТ_на_r2.png) 
![alt text](img/7_task/проверка_отключения_НАТ_на_r2.png)
---



## 7.11. Проверил соединение по TCP для SNAT: 
💬 *Для этого с ws22 подключился к серверу Apache на r1 командой:
telnet [адрес] [порт]*

![alt text](img/7_task/Проверка_SNAT_с_ws22.png) 

💬 *Также проверил соединение по TCP для DNAT, для этого с r1 подключаемся к серверу Apache на ws22 (обращаться по адресу r2 и порту 8080)*

![alt text](img/7_task/Проверить_подмену_IP-адреса.png)
---

 



## 7.12. Проверь соединение по TCP для DNAT: 

💬 *Для этого с r1 подключился к серверу Apache на ws22 командой telnet (обращаться по адресу r2 и порту 8080).*

![alt text](img/7_task/Проверка_DNAT_с_r1.png) 




💬 *Также проверил соединение по TCP для DNAT, для этого с r1 подключился к серверу Apache на ws22 (обращаться по адресу r2 и порту 8080)*

![alt text](img/7_task/Проверяем_соединение_по_TCP_для_DNAT.png) 
---























